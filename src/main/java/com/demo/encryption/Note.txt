Terms
    MITM attacks
        Man-in-the-middle attack
    inpersonate attacks
        impersonate the original request

    prying eyes
        over the shoulder 'attack'
    cipher
        algo / algorithm
    ciphertext
        encrpted text
    plaintext
        original message
    OAEP
        is more secure than PKCS#1 padding. If you choose OAEP then the padding overhead is even larger, making ECB even less efficient, OAEP value is randomized
    PKCS#1 padding
        there is a significant (11 byte) overhead for each block of plaintext.  PKCS#1 v1.5 value is randomized
    ECB:
        ECB is a symmetric cipher mode and RSA is an asymmetric cipher, So “ECB” has NO effect ( none ), so if you would use RSA in ECB mode then you would end up losing the padding overhead for each block.
    RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING


Oauth
    OAuth 1 uses signature-based authentication,
    OAuth 2 uses token-based authentication.

OAEP
    default for OAEP is to use SHA-1 for MGF1,
    OAEP is included in the implementation requirements for Java runtimes since Java 8
    RSA/ECB/OAEPWithSHA-1AndMGF1Padding (1024, 2048)
    RSA/ECB/OAEPWithSHA-256AndMGF1Padding (1024, 2048)
    ECB. “ECB” is a symmetric cipher mode and RSA is an asymmetric cipher, So “ECB” has no effect


MAC
     Block serialization and storage as String in JVM memory
     MAC means Message authentication code (MAC), sometimes known as a tag, is a short piece of information used to authenticate a message.
     In other words, to confirm that the message came from the stated sender (its authenticity) and has not been changed.
     The MAC value protects both a message's data integrity as well as its authenticity
     Sender: Mac    ||    Receiver: verify the MAC if the same MAC is found, then the message authentic and integrity checked. else : hacked/tempered

     Modes:  OMAC(CMAC), VMAC, HMAC and etc
     OMAC:
        One-key MAC (OMAC) is a message authentication code constructed from a block cipher much like the CBC-MAC algorithm.
     HMAC:
        Hash-Based Message Authentication Codes (HMACs)
        HMAC Block serialization and storage as String in JVM memory
        HMAC does NOT encrypt the message. Instead, the message (encrypted or not) must be sent alongside the HMAC hash. Parties with the secret key will hash the message again themselves, and if it is authentic, the received and computed hashes will match.
        HMAC (sometimes expanded as either keyed-hash message authentication code or hash-based message authentication code) is a specific type of message authentication code (MAC) involving a cryptographic hash function and a secret cryptographic key.
        Any cryptographic hash function, such as SHA-256 or SHA-3, may be used in the calculation of an HMAC, the resulting MAC algorithm is termed HMAC-X, where X is the hash function used (e.g. HMAC-SHA256 or HMAC-SHA3).

    Encrypt-then-MAC = Encrypt the plaintext, MAC the ciphertext + iv then append it to the ciphertext.
    MAC-then-Encrypt = MAC the plaintext then append the MAC to the plaintext then Encrypt it all.
    Encrypt-and-MAC = Encrypt and MAC the plaintext then append the MAC onto the ciphertext.


Encryption vs Hashing

    hash algorithm, which means that it is one-way. You can't get the original message after hashing it, namely:
        MD5 : not recommended, was discovered to fail the fourth password hashing property in that it became computationally easy to generate collisions.
        SHA1/SHA2
        SHA256
        SHA512:  not recommended in that When employed with salt, SHA-512 is still a fair option, but there are stronger and slower options out there
        PBKDF2:
        BCrypt: blow fish is fun
        SCrypt:
        etc.
        It should be deterministic: the same message processed by the same hash function should always produce the same hash
        It's not reversible: it's impractical to generate a message from its hash
        It has high entropy: a small change to a message should produce a vastly different hash
        And it resists collisions: two different messages should not produce the same hash

    encryption , which is two-way (allows encryption and decryption).
        "PKCS1Padding" indicates RSA with PKCS#1 v1.5 padding for encryption. This padding is indeterministic


Symmetric encryption
    This type of encryption uses a single key known as private key or secret key to encrypt and decrypt sensitive information,
    This type of encryption is very fast as compared to asymmetric encryption
    and are used in systems such as database system. Some examples of symmetric encryptions are Twofish, Blowfish(BCrypt), 3 DES, AES.

Asymmetric encryption
    Asymmetric encryption such as RSA uses two different keys as public and private keys.
    you can encrypt sensitive information with a public key and a matching private key is used to decrypt the same.

AES Encryption
    AES stands for Advanced Encryption System and its a symmetric encryption algorithm
    online tool:
        https://www.devglan.com/online-tools/aes-encryption-decryption

BCrypt:
    As per wiki, bcrypt is a password hashing function designed by Niels Provos and David Mazières,
    based on the Blowfish cipher. Bcrypt uses adaptive hash algorithm to store password.
    BCrypt internally generates a random salt while encoding passwords and hence it is obvious to get different encoded results for the same string.
    But one common thing is that everytime it generates a String of length 60.

    online tool:
        http://www.devglan.com/online-tools/bcrypt-hash-generator

    maven:
            <dependency>
                <groupId>org.mindrot</groupId>
                <artifactId>jbcrypt</artifactId>
            </dependency>


RSA
        // get pri/pub key pair https://lunar.lyris.com/help/lm_help/12.0/Content/generating_public_and_private_keys.html
        openssl genrsa -out rsa.private 1024
        openssl rsa -in rsa.private -out rsa.public -pubout -outform PEM

SHA-1 hashing
        SHA1 is a one way hashing algorithm. You can't get the original contents back
        SHA-1 (and all other hashing algorithms) return binary data. That means that (in Java) they produce a byte[],
        so use base64 to encode teh byte[] and return.
        Two common ways of representing arbitrary byte[] as printable characters are BASE64 or simple hex-Strings
        (i.e. representing each byte by two hexadecimal digits). It looks like you're trying to produce a hex-String.


JWT/JWS/JWA
    JWS:
        a signed JWT is called JWS, it looks like: eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJKb2UifQ.1KP0SsvENi7Uz1oQc07aXTL7kpQG5jBNIybqr60AlD4
    JWA:
        JSON Web Algorithms  - RFC 7518, A key of the same size as the hash output (for instance, 256 bits for "HS256") or larger MUST be used with this algorithm.

    HMAC-SHA
        JWT HMAC-SHA signature algorithms HS256, HS384, and HS512 require a secret key that is at least as many bits as the algorithm's signature (digest) length per RFC 7512 Section 3.2. This means:

        HS256 is HMAC-SHA-256, and that produces digests that are 256 bits (32 bytes) long, so HS256 requires that you use a secret key that is at least 32 bytes long.

        HS384 is HMAC-SHA-384, and that produces digests that are 384 bits (48 bytes) long, so HS384 requires that you use a secret key that is at least 48 bytes long.

        HS512 is HMAC-SHA-512, and that produces digests that are 512 bits (64 bytes) long, so HS512 requires that you use a secret key that is at least 64 bytes long.

SSL
    SSL is a lower level form of security, encrypting every request from and to the server to prevent interception and retains integrity.
    SSL is achieved by (purchasing) an SSL certificate and installing it on your server.
    SSL certificate is basically a small data file that binds a cryptographic key to an 'organisation'. Once installed succesfully, HTTPS requests (on port 443 by default) are possible.
    SSL Certificate encrypt your website and secure your sensitive information like username, password or credit card information.
    SSL Certificate works on two key pair, private key and public key. This key pair ensures that the data can be encrypted by one key but can only be decrypted by the other key pair.
    SSL Certificate also offers security seal/site seal that increase your website security as well as visitor's confidence.

    So, SSL Certificate is ideal if you want to secure your website, sensitive information, improve user's trust and also Google ranking.