enum Note:
        JDK 1.5 introduces a new enum type (in addition to the existing top-level constructs class and interface) along with a new keyword enum. For example, we could define: enum CardSuit { SPADE, DIAMOND, CLUB, HEART }
        for each enum, the Java compiler automatically generates a static method called values() that returns an array of all the enum constants,
        4 instances of enum type CardSuit were generated via values(). The instances are created by calling the constructor with the actual argument, when they are first referenced. You are not allowed to construct a new instance of enum using new operator, because enum keeps a fixed list of constants.
        An enum can be used to define a set of enum constants. The constants are implicitly static final, which cannot be modified. You could refer to these constants just like any static constants,
        All constants defined in an enum are public static final. Since they are static, they can be accessed via EnumName.instanceName.
        enums extend the java.lang.Enum class implicitly. Therefore, you cannot extend any other class in enum.
        An enum is a reference type (just like a class, interface and array), which holds a reference to memory in the heap. It is implicitly final, because the constants should not be changed.
        enum is a keyword. Enum constructors are always private or default. Therefore, you cannot have public or protected constructors in an enum type.
        Enum with abstract method Each of the instances of enum could have its own behaviors. To do this, you can define an abstract method in the enum, where each of its instances provides its own implementation.
        Enums can implement interfaces. They implicitly implement the Serializable and Comparable interfaces. This means if you need some common functionality along diverse enum types, you can define it with an interface to have the enums provide the method implementations.
        You can declare abstract methods within an enum. If you do, all the enum fields must implement the abstract methods.
        You cannot create an instance of enum using the new operator.
        You can use the “==” operator to compare enum constants effectively, since enum constants are final.
        Whenever an enum is defined, a class that extends java.lang.Enum is created

        # Compiled class
            public static final class EnumExample1$Season extends Enum
            {
              private EnumExample1$Season(String s, int i)
                {
                    super(s, i);
                }

                public static EnumExample1$Season[] values()
                {
                    return (EnumExample1$Season[])$VALUES.clone();
                }

                public static EnumExample1$Season valueOf(String s)
                {
                    return (EnumExample1$Season)Enum.valueOf(EnumExample1$Season, s);
                }

                public static final EnumExample1$Season WINTER;
                public static final EnumExample1$Season SPRING;
                public static final EnumExample1$Season SUMMER;
                public static final EnumExample1$Season FALL;
                private static final EnumExample1$Season $VALUES[];

                static
                {
                    WINTER = new EnumExample1$Season("WINTER", 0);
                    SPRING = new EnumExample1$Season("SPRING", 1);
                    SUMMER = new EnumExample1$Season("SUMMER", 2);
                    FALL = new EnumExample1$Season("FALL", 3);
                    $VALUES = (new EnumExample1$Season[] {
                        WINTER, SPRING, SUMMER, FALL
                    });
                }
            }

        # Static
            enum types that are defined as nested types are always implicitly STATIC, so If you declared an enum like this:

                    enum Suit {SPADES, HEARTS, CLUBS, DIAMONDS}

            The Java compiler would synthetically generate the following class for you:
            final class Suit extends java.lang.Enum<Suit> {
              public static final Suit SPADES;
              public static final Suit HEARTS;
              public static final Suit CLUBS;
              public static final Suit DIAMONDS;
              private static final Suit[] $VALUES;
              public static Suit[] values();
              public static Suit valueOf(java.lang.String);
              private Suit();
            }


        # SAM ( enum )
            An enum type can have abstract methods just like a class. Each enum constant needs to implement the abstract method. An example is as follows:

            public enum Animal {
              Dog { String sound() { return "bark"; } },
              Cat { String sound() { return "meow"; } },
              Lion { String sound() { return "roar"; } },
              Snake { String sound() { return "hiss"; } };
              abstract String sound();
            };

            then:
            String str = "Dog";
            Animal animal = Animal.valueOf(Animal.class, str);
            System.out.println(animal + " makes sound: " + animal.sound());
            // prints
            Dog makes sound: bark


        # valueOf() to look up an enum by the name.

            The java compiler internally adds the values() method when it creates an enum.
            The values() method returns an array containing all the values of the enum.

            private enum Day {
                SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
                THURSDAY, FRIDAY, SATURDAY
            };
            Day day = Day.valueOf(Day.class, "MONDAY");
            //The method throws an IllegalArgumentException if the name (with the exact case) is not found.  then use Day day = Day.valueOf(Day.class, "Monday");
            \
# Encounter order / Spatial order
        A source has or does not have encounter order.
        List and arrays are sources that have encounter order (arrays can be said to also have a spatial order).
        HashSet is a source that does not have encounter order (another example is PriorityQueue).

        A terminal operation preserves or does not preserve encounter order when producing a result.
        Non-preserving terminal operations are forEach, forEachUntil, findAny, match{Any, None, All}, collect(toHashSet()) and
        collectUnordered.

        An intermediate operation may inject encounter order down-stream.
        The sorted() operation injects encounter order when the natural comparator is used to sort elements.

        An intermediate operation may clear encounter order down-stream.
        There are no such operations implemented.
        (Previously the unordered() operation cleared encounter order.)

        Otherwise an intermediate operation must preserve encounter order if required to do so (see next paragraphs).

        An intermediate operation may choose to apply a different algorithm if encounter order of the elements output from the intermediate operation must be preserved or not.
        The distinct() operation will, when evaluating in parallel, use a ConcurrentHashMap to store unique elements if encounter order does not need to be preserved, otherwise if encounter order needs to be preserved a fold will be performed (equivalent of, in parallel, map each element to a singleton set then associatively reduce the sets to one set).

        An intermediate operation should preserve encounter order of the output elements if:

        a.1) the upstream elements input to the intermediate operation has an encounter order (either because the source has encounter order or because an upstream operation injected encounter order); and
        a.2) the terminal operation preserves encounter order.

        An intermediate operation does not need to preserve encounter order of the output elements if:

        b.1) the upstream elements input to the intermediate operation has no encounter order (either because the source has no encounter order or because an upstream operation cleared encounter order); or
        b.2) the terminal operation does not preserve encounter order *and* the intermediate operation is in a sequence of operations, to be evaluated, where the last operation in the sequence is the terminal operation and all operations in the sequence are evaluated in parallel.

        Rule b.2 above ensures that for the following pipeline encounter order is preserved on the sequential forEach:

         list.parallelStream().distinct().sequential().forEach()

        i.e. the distinct() operation will preserve the encounter order of the list

