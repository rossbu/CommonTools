
# Java tools
     # jconsole, jvisualvm, jmc

# Java command
    keytool -list -storepass changeit -keystore "C:\Program Files\Java\jre1.8.0_202\lib\security\cacerts
    perl analyze-ssl.pl -v3 --all-ciphers trackobot.com  (C:\Development\tools\p5-ssl-tools)

    where JAVA stores the private keys?
        Java doesn't store them anywhere.
        You store them in a keystore file, anywhere you want on the file system. Then you tell the "server" where it is.
        Exactly how you do that depends on what the "server" is, e.g. for Tomcat you give the path to the keystore file in the server.xml file.

# enum
        JDK 1.5 introduces a new enum type (in addition to the existing top-level constructs class and interface) along with a new keyword enum. For example, we could define: enum CardSuit { SPADE, DIAMOND, CLUB, HEART }
        for each enum, the Java compiler automatically generates a static method called values() that returns an array of all the enum constants,
        4 instances of enum type CardSuit were generated via values(). The instances are created by calling the constructor with the actual argument, when they are first referenced.
         You are not allowed to construct a new instance of enum using new operator, because enum keeps a fixed list of constants.

        An enum can be used to define a set of enum constants. The constants are implicitly static final, which cannot be modified. You could refer to these constants just like any static constants,
        All constants defined in an enum are public static final. Since they are static, they can be accessed via EnumName.instanceName.

        enums extend the java.lang.Enum class implicitly. Therefore, you cannot extend any other class in enum.
        An enum is a reference type (just like a class, interface and array), which holds a reference to memory in the heap. It is implicitly final, because the constants should not be changed.

        enum is a keyword. Enum constructors are always private or default. Therefore, you cannot have public or protected constructors in an enum type.
        Enum with abstract method Each of the instances of enum could have its own behaviors. To do this, you can define an abstract method in the enum, where each of its instances provides its own implementation.

        Enums can implement interfaces. They implicitly implement the Serializable and Comparable interfaces. This means if you need some common functionality along diverse enum types, you can define it with an interface to have the enums provide the method implementations.
        You can declare abstract methods within an enum. If you do, all the enum fields must implement the abstract methods.
        You cannot create an instance of enum using the new operator.
        You can use the “==” operator to compare enum constants effectively, since enum constants are final.

        Whenever an enum is defined, a class that extends java.lang.Enum is created

        ## Compiled class
            public static final class EnumExample1$Season extends Enum
            {
              private EnumExample1$Season(String s, int i)
                {
                    super(s, i);
                }

                public static EnumExample1$Season[] values()
                {
                    return (EnumExample1$Season[])$VALUES.clone();
                }

                public static EnumExample1$Season valueOf(String s)
                {
                    return (EnumExample1$Season)Enum.valueOf(EnumExample1$Season, s);
                }

                public static final EnumExample1$Season WINTER;
                public static final EnumExample1$Season SPRING;
                public static final EnumExample1$Season SUMMER;
                public static final EnumExample1$Season FALL;
                private static final EnumExample1$Season $VALUES[];

                static
                {
                    WINTER = new EnumExample1$Season("WINTER", 0);
                    SPRING = new EnumExample1$Season("SPRING", 1);
                    SUMMER = new EnumExample1$Season("SUMMER", 2);
                    FALL = new EnumExample1$Season("FALL", 3);
                    $VALUES = (new EnumExample1$Season[] {
                        WINTER, SPRING, SUMMER, FALL
                    });
                }
            }

        ## Static
            enum types that are defined as nested types are always implicitly STATIC, so If you declared an enum like this:

                    enum Suit {SPADES, HEARTS, CLUBS, DIAMONDS}

            The Java compiler would synthetically generate the following class for you:
            final class Suit extends java.lang.Enum<Suit> {
              public static final Suit SPADES;
              public static final Suit HEARTS;
              public static final Suit CLUBS;
              public static final Suit DIAMONDS;
              private static final Suit[] $VALUES;
              public static Suit[] values();
              public static Suit valueOf(java.lang.String);
              private Suit();
            }


        ## SAM ( enum )
            An enum type can have abstract methods just like a class. Each enum constant needs to implement the abstract method. An example is as follows:

            public enum Animal {
              Dog { String sound() { return "bark"; } },
              Cat { String sound() { return "meow"; } },
              Lion { String sound() { return "roar"; } },
              Snake { String sound() { return "hiss"; } };
              abstract String sound();
            };

            then:
            String str = "Dog";
            Animal animal = Animal.valueOf(Animal.class, str);
            System.out.println(animal + " makes sound: " + animal.sound());
            // prints
            Dog makes sound: bark


        ## valueOf() to look up an enum by the name.

            The java compiler internally adds the values() method when it creates an enum.
            The values() method returns an array containing all the values of the enum.

            private enum Day {
                SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
                THURSDAY, FRIDAY, SATURDAY
            };
            Day day = Day.valueOf(Day.class, "MONDAY");
            //The method throws an IllegalArgumentException if the name (with the exact case) is not found.  then use Day day = Day.valueOf(Day.class, "Monday");
            \

# Encounter order / Spatial order
        A source has or does not have encounter order.
        List and arrays are sources that have encounter order (arrays can be said to also have a spatial order).
        HashSet is a source that does not have encounter order (another example is PriorityQueue).

        A terminal operation preserves or does not preserve encounter order when producing a result.
        Non-preserving terminal operations are forEach, forEachUntil, findAny, match{Any, None, All}, collect(toHashSet()) and
        collectUnordered.

        An intermediate operation may inject encounter order down-stream.
        The sorted() operation injects encounter order when the natural comparator is used to sort elements.

        An intermediate operation may clear encounter order down-stream.
        There are no such operations implemented.
        (Previously the unordered() operation cleared encounter order.)

        Otherwise an intermediate operation must preserve encounter order if required to do so (see next paragraphs).

        An intermediate operation may choose to apply a different algorithm if encounter order of the elements output from the intermediate operation must be preserved or not.
        The distinct() operation will, when evaluating in parallel, use a ConcurrentHashMap to store unique elements if encounter order does not need to be preserved, otherwise if encounter order needs to be preserved a fold will be performed (equivalent of, in parallel, map each element to a singleton set then associatively reduce the sets to one set).

        An intermediate operation should preserve encounter order of the output elements if:

        a.1) the upstream elements input to the intermediate operation has an encounter order (either because the source has encounter order or because an upstream operation injected encounter order); and
        a.2) the terminal operation preserves encounter order.

        An intermediate operation does not need to preserve encounter order of the output elements if:

        b.1) the upstream elements input to the intermediate operation has no encounter order (either because the source has no encounter order or because an upstream operation cleared encounter order); or
        b.2) the terminal operation does not preserve encounter order *and* the intermediate operation is in a sequence of operations, to be evaluated, where the last operation in the sequence is the terminal operation and all operations in the sequence are evaluated in parallel.

        Rule b.2 above ensures that for the following pipeline encounter order is preserved on the sequential forEach:

         list.parallelStream().distinct().sequential().forEach()

        i.e. the distinct() operation will preserve the encounter order of the list

# countdownlatch
     When should we use CountDownLatch in Java :
     Use CountDownLatch when one of Thread like main thread, require to wait for one or more thread to complete, before its start doing processing.
     trty CountDownDemo.java to see details.

# fail-fast strategy by Objects.requireNotNull from jdk7/8/9
    check FailFastByRequireNonNull.java for reference.

# Default constructor is required (Explicitly) in a parent class if the parent class has an argumented constructor.
        http://xahlee.info/java-a-day/inheritance_constructers.html
        If you are explicitly providing an argument-ed constructor, then the default constructor (NOT-argumented | Empty args) is NOT available to the class.

        For Example :
            class A {
              A(int i){
              }
            }

            class B extends A {
            }

            So when you write

            B obj_b = new B();
            It actually calls the implicit constructor provided by java to B, which again calls the super(), which should be ideally A().
            But since you have provided argument-ed constructor to A, the default constructor A() is not available to B().

        Solution
            class B {
              int x;
              //B () {x=300;}
              B (int n) {x=n;}
              int returnMe () {return x;}
            }

            class C extends B {
            }


            the answer to the constructor mystery is that, if one provides any constructor, one must define all constructors.

            Peter Molettiere on Apple's Java forum gave excellent answers:

            Because there is no default constructor available in B, as the compiler error message indicates. Once you define a constructor in a class, the default constructor is not included.
            If you define *any* constructor, then you must define *all* constructors.

            When you try to instantiate C, it has to call super() in order to initialize its super class. You don't have a super(), you only have a super(int n), so C can not be defined with the default constructor C() { super(); }. Either define a no-arg constructor in B, or call super(n) as the first statement in your constructors in C.

            So, the following would work:

            class B {
                int x;
                B() { } // a constructor
                B( int n ) { x = n; } // a constructor
                int returnMe() { return x; }
            }

            class C extends B {
            }
            or this:

            class B {
                int x;
                B( int n ) { x = n; } // a constructor
                int returnMe() { return x; }
            }

            class C extends B {
                C () { super(0); } // a constructor
                C (int n) { super(n); } // a constructor
            }

# Final
        When should I use final?
        One answer to this is "whenever you possibly can". Any field that you never expect to be changed (be that a primitive value, or a reference to an object, whether or not that particular object is itself immutable or not), should generally be declared final. Another way of looking at things is:

        If your object is accessed by multiple threads, and you don't declare its fields final, then you must provide thread-safety by some other means.
        Other means could include declaring the field volatile, using synchronized or an explicit Lock around all accesses to that field.

        A typical case that people overlook is where an object is created by one thread and then later consumed by another thread, e.g. an object via a ThreadPoolExecutor. In this case, the object must still be made properly thread-safe: it doesn't matter that the accesses by different threads aren't concurrent.
        What matters is that the object is accessed by different threads at any point in its lifetime.